# Guide_oleg  JavaScript Style Guide


#Форматирование

Терминологическое примечание: блокоподобная конструкция относится к телу класса, функции, метода или блока кода, разделенного скобками. Обратите внимание, что по правилам 5.2 Литералы массива и 5.3 Литералы объекта любой массив или объектный литерал может опционально обрабатываться, как если бы это была блочная конструкция.

Подсказка: Используйте clang-format. Сообщество JavaScript приложило усилия, чтобы убедиться, что clang-format правильно работает в JavaScript файлах. clang-format имеет интеграцию с несколькими популярными редакторами.

#Скобки

Скобки используются для всех управляющих структур
Скобки требуются для всех управляющих структур (например, if, else, for, do, while и т.п.), даже если тело содержит один оператор. Первый оператор непустого блока должен начинаться с отдельной строки.

Не разрешено:
if (someVeryLongCondition()) doSomething();
for (let i = 0; i < foo.length; i++) bar(foo[i]);
Исключение: Простой оператор if, который может поместиться целиком в одну строку без переноса (и в котором нет другого), может быть помещен в одной строке без фигурных скобок, когда он улучшает читабельность. Это единственный случай, когда управляющая структура может пропускать скобки и переводы строк.

if (shortCondition()) foo();

#Непустые блоки: стиль K&R
Скобки следуют стилю Кернигана и Ричи (египетские скобки) для непустых блоков и блочных конструкций, если:

Никакого разрыва строки перед открывающей скобкой.
Разрыв строки после открывающей скобки.
Разрыв строки перед закрывающей скобкой.
Разрыв строки после закрывающей скобки if. Данная фигурная скобка завершает оператор или тело оператора функции или класса или метод класса. В частности, после фигурной скобки нет разрыва строки, если за ней следует else, catch, while или запятая, точка с запятой или правая скобка.
Пример:

class InnerClass {
  constructor() {}

  /** @param {number} foo */
  method(foo) {
    if (condition(foo)) {
      try {
        // Внимание: это может не сработать.
        something();
      } catch (err) {
        recover();
      }
    }
  }
}

#Пустые блоки: могут быть краткими
Пустой блок или блочно-подобная конструкция может быть закрыта сразу после открытия, но без символов, пробелов или разрыва строки между ними (например, {}), Если только это не является частью многоблочного оператора (который содержит непосредственно несколько блоков: if/else или try/catch/finally).

Пример:

function doNothing() {}
Запрещено:

if (condition) {
  // …
} else if (otherCondition) {} else {
  // …
}

try {
  // …
} catch (e) {}

#Блочный отступ: +2 пробела
Каждый раз, когда открывается новый блок или блочная конструкция, отступ увеличивается на два пробела. Когда блок заканчивается, отступ возвращается к предыдущему уровню отступа. Уровень отступа применяется как к коду, так и к комментариям по всему блоку. (см. пример в 4.1.2 Непустые блоки: стиль K&R ).

#Литералы массива: опционально блочные
Любой литерал массива может быть необязательно отформатирован так, как если бы он был «блочной конструкцией». Например, допустимые варианты ниже (не исчерпывающий список):

const a = [
  0,
  1,
  2,
];

const b =
    [0, 1, 2];
const c = [0, 1, 2];

someMethod(foo, [
  0, 1, 2,
], bar);
Допускаются другие комбинации, особенно при подчеркивании семантических группировок между элементами, но они не должны использоваться только для уменьшения вертикального размера больших массивов.

 4.2.2 Объектные литералы: опционально блочные
Любой объектный литерал может быть отформатирован так, как если бы он был «блочной конструкцией». Применяются те же примеры, что и 4.2.1 Литералы массива: опционально блочные . Например, следующие примеры допустимы (не исчерпывающий список):

const a = {
  a: 0,
  b: 1,
};

const b =
    {a: 0, b: 1};
const c = {a: 0, b: 1};

someMethod(foo, {
  a: 0, b: 1,
}, bar);

#Литералы класса
Литералы класса (будь то объявления или выражения) имеют отступ в виде блоков. Не добавляйте точку с запятой после методов или после закрывающей скобки объявления класса (операторы, такие как присваивания, которые содержат выражения класса, по-прежнему заканчиваются точкой с запятой). Используйте ключевое слово extends, но не аннотацию @extends JSDoc, если только класс не расширяет шаблонизированный тип.

Пример:

class Foo {
  constructor() {
    /** @type {number} */
    this.x = 42;
  }

  /** @return {number} */
  method() {
    return this.x;
  }
}
Foo.Empty = class {};
/** @extends {Foo<string>} */
foo.Bar = class extends Foo {
  /** @override */
  method() {
    return super.method() / 2;
  }
};

/** @interface */
class Frobnicator {
  /** @param {string} message */
  frobnicate(message) {}
}

#Функциональные выражения
При объявлении анонимной функции в списке аргументов для вызова функции, тело функции имеет отступ на два пробела больше, чем предыдущая глубина отступа.

Пример:

prefix.something.reallyLongFunctionName('whatever', (a1, a2) => {
  // Отступ тела функции +2 относительно глубины отступа
  // оператора на одну строку выше.
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

some.reallyLongFunctionCall(arg1, arg2, arg3)
    .thatsWrapped()
    .then((result) => {
      // Отступ тела функции +2 относительно глубины отступа
      // вызова '.then()'.
      if (result) {
        result.use();
      }
    });

#Switch оператор
Как и в любом другом блоке, содержимое блока switch имеет отступ +2.

После оператора switch добавляется новая строка и уровень отступа увеличивается на +2, точно так же, как если бы блок открывался. Явный блок может использоваться, если этого требует лексическая область видимости. После завершения оператора отступ возвращается на предыдущий уровень.

Пустая строка необязательна между break и следующим случаем.

Пример:

switch (animal) {
  case Animal.BANDERSNATCH:
    handleBandersnatch();
    break;

  case Animal.JABBERWOCK:
    handleJabberwock();
    break;

  default:
    throw new Error('Неизвестное животное');
}

#Операторы

Один оператор на строку
После каждого оператора делается перевод строки.

#Необходима точка с запятой.
Каждый оператор должен заканчиваться точкой с запятой. Использование автоматической точки с запятой запрещено.

#Лимит строки: 80 символов
Код JavaScript имеет ограничение столбца в 80 символов. За исключением случаев, указанных ниже, любая строка, которая превысила бы этот предел, должна быть перенесена, как описано в 4.5 Перенос строк.

Исключения:

Операторы goog.module, goog.require и goog.requireType (см. 3.3 Оператор goog.module и 3.6 Операторы goog.require и goog.requireType ).
ES модули import и операторы export from (см. 3.4.1 Импорт и 3.4.2.4 export from).
Линии, в которых соблюдение предела столбцов невозможно или может препятствовать обнаружению. Примеры включают в себя:
Длинный URL, который должен быть кликабельным в источнике.
Команда консоли, предназначенная для копирования и вставки
Длинный строковый литерал, который может потребоваться полностью скопировать или найти (например, длинный путь к файлу).
4.5 Перенос строк
Терминологическое примечание: Перенос строки разбивает кусок кода на несколько строк в соответствии с ограничением по количеству символов, где фрагмент в противном случае мог бы поместиться в одну строку в соответствии с правилами данного руководства.

Не существует всеобъемлющего правила, показывающего, как именно переносить строки в каждой ситуации. Очень часто есть несколько допустимых способов переноса строк в одном и том же фрагменте кода.

Примечание: Хотя типичная причина переноса строки заключается в том, чтобы избежать переполнения предела столбца — даже код, который на самом деле помещается в пределе допустимого количества символов, может быть разбит строкой на усмотрение автора.

Совет: извлечение метода или локальной переменной может решить проблему без необходимости переноса строки.

#Когда переносить
Основная директива переноса строк такова: предпочитайте переносить на более высоком синтаксическом уровне.

Предпочтительно:

currentEstimate =
    calc(currentEstimate + x * currentEstimate) /
        2.0;
Нежелательно:

currentEstimate = calc(currentEstimate + x *
    currentEstimate) / 2.0;
В предыдущем примере синтаксические уровни от самого высокого до самого низкого следующие: определение, деление, вызов функции, параметры, числовая константа.

Операторы переносятся следующим образом:

Когда у оператора разрывается строка, разрыв следует за оператором. (Обратите внимание, что это не та же практика, что и в стиле Google для Java.)
Это не относится к точке (.), которая на самом деле не является оператором.
Имя метода или конструктора остается присоединенным к открытой круглой скобке ((), которая следует за ней.
Запятая (,) остается прикрепленной к символу, который предшествует ей.
Примечание: Основной целью переноса строк является наличие понятного кода, а не обязательно кода, который помещается в наименьшее количество строк.

#Отступ строк с протяженностью не менее +4 пробелов
При переносе строк каждая строка после первой (каждая строка продолжения ) имеет отступ не менее +4 от исходной строки, если только она не подпадает под правила отступа блока.

Когда имеется несколько строк продолжения, отступ может выходить за пределы +4 в зависимости от ситуации. Как правило, строки продолжения на более глубоком синтаксическом уровне имеют отступ с большим числом, кратным 4. Две строки используют один и тот же уровень отступа, если и только если они начинаются с синтаксически равных элементов.

#Горизонтальное выравнивание: не рекомендуется объясняет нежелательную практику использования переменного числа пробелов для выравнивания определенных конструкций с предыдущим типом строк.

#Пробелы

Вертикальный пробел
Одна пустая строка ставится:

Между последовательными методами в литерале класса или объекта
Исключение: пустая строка между двумя последовательными определениями свойств в литерале объекта (без другого кода между ними) является необязательной. Такие пустые строки используются по мере необходимости для создания логических группировок полей.
Внутри тел методов имеет смысл создавать логические группировки операторов. Пустые строки в начале или конце тела функции не допускаются.
Необязательно перед первым или после последнего метода в литерале класса или объекта (не рекомендуется и не поощряется).
Как того требуют другие разделы этого документа (например, 3.6 Операторы goog.require и goog.requireType ).
Несколько последовательных пустых строк разрешены, но никогда не требуются (и не поощряются).

#Горизонтальный пробел
Использование горизонтального пробела зависит от местоположения и подразделяется на три широкие категории: ведущий (в начале строки), конечный (в конце строки) и внутренний. Ведущий пробел (то есть отступ) рассматривается в другом месте. Конечный пробел запрещен.

Кроме случаев, когда этого требуют правила языка или другие правила стиля, а также литералы, комментарии и JSDoc, один ASCII пробел появляется только в следующих местах:

Отделение любого зарезервированного слова (например, if, for или catch), за исключением function и super начиная с открытой скобки ((), которая следует за зарезервированным словом в этой же строке.
Отделение любого зарезервированного слова (такого как else или catch) от закрывающей фигурной скобки (}), которая предшествует ему в этой строке.
Перед любой открытой фигурной скобкой ({), с двумя исключениями:
Перед литералом объекта, который является первым аргументом функции или первым элементом в литерале массива (например, foo ({a: [{c: d}]}) ).
В расширении шаблона, так как это запрещено языком (например, валидно: `ab${1 + 2}cd`, не валидно: `xy$ {3}z`).
С обеих сторон любой бинарного или тернарного оператор.
После запятой (,) или точки с запятой (;). Обратите внимание, что пробелы никогда не разрешены перед этими символами.
После двоеточия (:) в литерале объекта.
По обе стороны от двойной косой черты (//), начинающей комментарий в конце строки. Здесь разрешено использование нескольких пробелов, но это не обязательно.
После символа блочного комментария и с обеих сторон закрывающих символов (например, для кратких объявлений типов, приведений и комментариев имени параметра: this.foo = /** @type {number} */ (bar); или function(/** string */ foo) {; или baz(/* buzz= */ true)).
 4.6.3 Горизонтальное выравнивание: не рекомендуется
Терминологическое примечание: Горизонтальное выравнивание — это практика добавления в ваш код переменного числа дополнительных пробелов с целью отображения определенных символов непосредственно под некоторыми другими символами в предыдущих строках.

Эта практика разрешена, но, как правило, не рекомендуется в Google Style. Даже не требуется поддерживать горизонтальное выравнивание в местах, где оно уже использовалось.

Вот пример без выравнивания, за которым следует пример с выравниванием. Оба разрешены, но последний не рекомендуется:

{
  tiny: 42, // хорошо
  longer: 435, // тоже хорошо
};

{
  tiny:   42,  // разрешено, но требует будущего редактирования
  longer: 435, // может остаться без выравнивания
};
Совет: Выравнивание может улучшить читаемость, но создает проблемы для дальнейшего обслуживания. Допустим, есть изменение, которое должно касаться только одной строки. Это изменение может оставить искаженное ранее приятное форматирование. Чаще всего это побуждает разработчика (возможно, вас) также корректировать пробелы на близлежащих линиях. Это изменение в одну строку потребовало изменения нескольких строк. В лучшем случае это может привести к бессмысленной занятой работе, но в худшем это еще и исказит информацию об истории версий, замедлит работу рецензентов и усугубит конфликты слияний.

#Аргументы функций
Предпочитайте помещать все аргументы функции в одну строку с именем функции. Если это превысит ограничение в 80 столбцов, аргументы должны быть перенесены для удобочитаемости. Чтобы сэкономить место, вы можете сделать перенос строки как можно ближе к 80 символам или поместить каждый аргумент в отдельной строке, чтобы улучшить читаемость. Отступы должны быть в размере 4-х пробелов. Выравнивание в скобках разрешено, но не рекомендуется. Ниже приведены наиболее распространенные шаблоны для переноса аргументов:

// Аргументы начинаются с новой строки, с отступом в четыре пробела. Предпочтительнее,
// когда аргументы помещаются не в одну строку с именем функции (или ключевым словом
// "function"), а помещаются полностью на второй строке. Такой подход работает с длинными
// именами функций, позволяет делать переименование без изменения отступов.
doSomething(
    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {
  // …
}

// Если список аргументов длинный (больше 80 символов), сделайте перенос.
// Такой подход использует меньше вертикального пространства, но нарушает
// правило прямоугольника и поэтому не рекомендуется.
doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // …
}

// Четыре пробела, один аргумент в строке. Работает с длинными именами
// функций, позволяет переименование, и выделяет каждый аргумент.
doSomething(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
  // …
}

#Группировка скобок: рекомендуется
Необязательные групповые скобки опускаются только в том случае, если автор и рецензент согласны с тем, что без них нет никакой разумной вероятности, что код будет неверно истолкован, и что они не сделали бы код более удобным для чтения. Неразумно предполагать, что каждый читатель запомнил всю таблицу операторов.

Не используйте лишние скобки вокруг всего выражения после delete, typeof, void, return, throw, case, in, of или yield.

Круглые скобки необходимы для приведения типов: /** @тип {!Foo}. */(foo).

#Комментарии
В этом разделе рассматриваются комментарии реализации. JSDoc рассматривается отдельно в 7 JSDoc.

#Стиль блочных комментариев
Блочные комментарии снабжены отступом на том же уровне, что и окружающий код. Они могут быть в стиле /* … */ или //. Для многострочных комментариев /* … */ последующие строки должны начинаться с *, выровненного с * на предыдущей строке, чтобы комментарии были очевидны без лишнего контекста.

/*
 * Это выглядит
 * хорошо.
 */

// Тоже
// хорошо.

/* Аналогично */
Комментарии не вставляются в поля, отрисованные звездочками или другими символами.

Не используйте JSDoc (/** … */) для комментариев, описывающих реализацию.

#Комментарии для имен параметров
Комментарии для имен параметров следует использовать во всех случаях, когда значение и имя метода не передают в достаточной степени смысл, а рефакторинг метода для большей ясности невозможен. Предпочтительный для них формат — перед значением с =:

someFunction(obviousParam, /* shouldRender= */ true, /* name= */ 'hello');
Для согласованности с окружающим кодом можно поместить их после значения без =:

someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);
